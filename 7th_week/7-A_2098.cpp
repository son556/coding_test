#include "test.hpp"
// dp 완전탐색 + 메모이제이션
// 생각의 순서: 1.완전탐색 -> 경우의 수 너무 큼 -> 2. 메모이제이션(배열, 맵 등) 가능한가  -> \
 3. 배열이 1000만정도 필요해 보인다 -> 그리디 혹은 다른 알고리즘
// dp 는 방향성이 있고 싸이클이 없어야 한다
// 1 문제를 잘 정의 할 것 2 부분문제들 사이의 관계를 파악할 것

// #include <bits/stdc++.h> 
#define MAX_N 16
const int INF = 987654321;
using namespace std; 
int n, dp[MAX_N][1 << MAX_N], dist[MAX_N][MAX_N];

int tsp(int here, int visited){
    if(visited == (1 << n) - 1){
        return dist[here][0] ? dist[here][0] : INF;
    }
    int &ret = dp[here][visited];
    if(ret != -1) return ret;
    ret = INF;
    for(int i = 0; i < n; i++){
        if(visited & (1 << i)) continue;
        if(dist[here][i] == 0) continue;
        ret = min(ret, tsp(i, visited | (1 << i)) + dist[here][i]);
    }
    return ret;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    cin >> n;
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            cin >> dist[i][j];
        }
    }
    memset(dp, -1, sizeof(dp));
    cout << tsp(0, 1) << '\n';
    return 0;
}


// 16
// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
// 1600 0 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615
// 3200 3201 0 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215
// 4800 4801 4802 0 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815
// 6400 6401 6402 6403 0 6405 6406 6407 6408 6409 6410 6411 6412 6413 6414 6415
// 8000 8001 8002 8003 8004 0 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015
// 9600 9601 9602 9603 9604 9605 0 9607 9608 9609 9610 9611 9612 9613 9614 9615
// 11200 11201 11202 11203 11204 11205 11206 0 11208 11209 11210 11211 11212 11213 11214 11215
// 12800 12801 12802 12803 12804 12805 12806 12807 0 12809 12810 12811 12812 12813 12814 12815
// 14400 14401 14402 14403 14404 14405 14406 14407 14408 0 14410 14411 14412 14413 14414 14415
// 16000 16001 16002 16003 16004 16005 16006 16007 16008 16009 0 16011 16012 16013 16014 16015
// 17600 17601 17602 17603 17604 17605 17606 17607 17608 17609 17610 0 17612 17613 17614 17615
// 19200 19201 19202 19203 19204 19205 19206 19207 19208 19209 19210 19211 0 19213 19214 19215
// 20800 20801 20802 20803 20804 20805 20806 20807 20808 20809 20810 20811 20812 0 20814 20815
// 22400 22401 22402 22403 22404 22405 22406 22407 22408 22409 22410 22411 22412 22413 0 22415
// 24000 24001 24002 24003 24004 24005 24006 24007 24008 24009 24010 24011 24012 24013 24014 0